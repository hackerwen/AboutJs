<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>原型链实例</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
    

    <script type="text/javascript">
    	function SuperType(){
            this.colors=['red','blue','black'];//超类实例成员
        }

        SuperType.prototype.sayHello=function(){
            console.log('hello');
        };//超类原型成员

        function SubType(){
            this.sex="male";//子类实例成员;
        }

        SubType.prototype=new SuperType()//继承
        SubType.prototype.constructor=SubType;//保持闭三角关系

        var subObj1=new SubType();//子类实例对象1
        var subObj2=new SubType();//子类实例对象2

        //到此为止,我们就完成了一个经典的原型链式继承

        //可以看出子类实例对象1 2都拥有了new SuperType()的成员,包括其 实例方法以及原型方法

        console.log(subObj1);
        console.log(subObj2);

        //但存在一个问题,倘若修改子类实例对象1的colors会影响到实例对象2,这也就是为什么很少单独使用原型链式继承的原因,就和为什么很少使用单独使用原型模式创建对象一样.

        subObj1.colors.push('white');//改变subObj1的colors

        console.log(subObj2.colors);//影响到了subObj2的colors

    </script>
</body>
</html>